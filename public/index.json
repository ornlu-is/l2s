[{"categories":["Leetcode"],"content":"The first problem I did was pretty simple so lets see if the second one is a bit more interesting: Given two strings, write a method to decide if one is a permutation of the other. The first thing to understand is what would classify the strings as being a permutation of one another. Sure we could generate all permutations and check them all, but that would be horribly inefficient and not particularly easier to code. For a string to be a permutation of another they both must have the same characters and they must show up in equal number. This means that all we have to do is get the frequency counts of each string and check if these match. For that purpose we can use a dictionary. However, since this is such a common thing, Python already provides a class designed for such situations, the Counter. We use it to get the frequency counts of the first string, then we use its method subtract to subtract the frequency counts of the second string. Now, if there are any new keys after subtracting, then the strings had different characters and are not palindromes. If the total sum on frequency counts isn’t zero, then it means the strings have the same characters but they show up in different numbers. Putting this together into code and throwing some unit tests in there, we get the following script. import unittest from collections import Counter from dataclasses import dataclass class PermutationChecker(): def check(self, string_1: str, string_2: str) -\u003e bool: character_counts = Counter(string_1) pre_num_chars = len(character_counts) character_counts.subtract(string_2) post_num_chars = len(character_counts) has_same_characters = pre_num_chars == post_num_chars has_same_character_count = character_counts.total() == 0 return True if (has_same_characters and has_same_character_count) else False class TestPermutationChecker(unittest.TestCase): def test_check(self): @dataclass class TestCase: name: str str1: str str2: str expected: bool test_cases = [TestCase(name=\"permutation with just letters\", str1=\"abcd\", str2=\"bacd\", expected=True), TestCase(name=\"permutation with just numbers\", str1=\"3563476\", str2=\"7334566\", expected=True), TestCase(name=\"permutation with alphanumeric\", str1=\"wef34f\", str2=\"wffe34\", expected=True), TestCase(name=\"not a permutation because of different length\", str1=\"abcd\", str2=\"d2cba\", expected=False), TestCase(name=\"not a permutation because of different characters\", str1=\"2354\", str2=\"1234\", expected=False)] checker = PermutationChecker() for tc in test_cases: res = checker.check(tc.str1, tc.str2) self.assertEqual(tc.expected, res, f\"[{tc.name}] - expected {tc.expected} but got {res}\") if __name__ == '__main__': unittest.main() ","date":"2025-01-26","objectID":"/check_permutation/:0:0","tags":[],"title":"Leetcode 2: Check permutation","uri":"/check_permutation/"},{"categories":null,"content":"Hi, I’m Luís! This is where I write about projects I’ve been working on, and also where I post some of my study notes, to keep everything organized and easily shareable. ","date":"2025-01-25","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Work I currently work as a Software Engineer for Stripe. Previously I worked as a Systems Engineer for Cloudflare and before that I worked for freiheit.com technologies as a Software Engineer. ","date":"2025-01-25","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Academic studies I have a BSc in Engineering Physics and a MSc in Applied Mathematics, both granted by University of Lisbon - Instituto Superior Técnico. ","date":"2025-01-25","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":["Leetcode"],"content":"The company I work for decided to do layoffs and fortunately I was not impacted. However, it did get me thinking on whether or not I felt ready to interview with other companies in case I had been fired. And I honestly don’t feel that ready. As such, I bought the Cracking the Coding Interview book and I’m going to be solving every single question that is in the book. Worst case scenario, I’ll learn some new stuff, which isn’t that bad. Plus, I’ll get to refresh my Python knowledge, which is always nice. Okay, first exercise here we go: implement an algorithm to determine if a string has all unique characters. Side note: this is called a heterogram. This is fairly straightforward to solve, all I need to do is iterate over the characters in the string while keeping a ledger of the characters I’ve already seen. I’ll also sprinkle in some nicely formatted unit tests just for good measure. To ensure that this ledger is efficient for lookups (since we’ll have to check every character against it), we use a hashmap to have constant time access. import unittest from dataclasses import dataclass class HeterogramChecker(): def check(self, text): seen = {} for c in text: if c in seen: return False else: seen[c] = True return True class TestHeterogramChecker(unittest.TestCase): def test_check(self): @dataclass class TestCase: name: str input: str expected: bool test_cases = [ TestCase(name=\"heterogram with just letters\", input=\"abcd\", expected=True), TestCase(name=\"heterogram with letters and number\", input=\"s4fad\", expected=True), TestCase(name=\"empty string\", input=\"\", expected=True), TestCase(name=\"repeated number in string\", input=\"23ds2\", expected=False), TestCase(name=\"several repeated characters in string\", input=\"hb 627jh=j ()\", expected=False)] checker = HeterogramChecker() for tc in test_cases: res = checker.check(text=tc.input) self.assertEqual( res, tc.expected, msg=f\"[{tc.name}] expected {tc.expected}, but got {res}\") if __name__ == \"__main__\": unittest.main() ","date":"2025-01-25","objectID":"/is_unique/:0:0","tags":[],"title":"Leetcode 1: Is unique?","uri":"/is_unique/"}]