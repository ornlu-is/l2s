[{"categories":["Leetcode"],"content":"Problem statement: Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\". First, let’s set the obvious limitation of our result: it is either the empty string or our result is at most equal to the smallest string in the given array. With this in mind, we get a first obvious solution, check all substrings of all of the given strings (in ascending order of length) up until the point where we find a mismatch between them. The previously observed substring will then correspond to the longest common prefix. The second solution is also obvious also doing the first (as it’s also faster). We can simply substitute the linear search part of the code with a binary search and we’ll get much better results. Plus, this was a good excuse to use a closure. import unittest from typing import List from dataclasses import dataclass class LCPFinder(): def with_linear_search(self, strs: List[str]): prefix = \"\" max_prefix_size = min([len(s) for s in strs]) for i in range(1, max_prefix_size+1): if all(s[:i] == strs[0][:i] for s in strs): prefix = strs[0][:i] return prefix def with_binary_search(self, strs: List[str]): max_prefix_size = min([len(s) for s in strs]) low, high = 1, max_prefix_size while low \u003c= high: middle = (low + high) // 2 def compare_strings(): s0 = strs[0][:middle] for i in range(1, len(strs)): if not strs[i][:middle] == s0: return False return True if compare_strings(): low = middle + 1 else: high = middle - 1 return strs[0][:(low + high) // 2] class TestLCPFinder(unittest.TestCase): def test_find(self): @dataclass class TestCase: name: str strs: list expected: str test_cases = [ TestCase(name=\"single string with one character in list\", strs=[\"a\"], expected=\"a\"), TestCase(name=\"lcp exists\", strs=[\"flower\",\"flow\",\"flight\"], expected=\"fl\"), TestCase(name=\"lcp does not exist\", strs=[\"dog\",\"racecar\",\"car\"], expected=\"\"), ] finder = LCPFinder() for tc in test_cases: res = finder.with_linear_search(tc.strs) self.assertEqual(tc.expected, res, f\"[{tc.name}] - expected {tc.expected}, but got {res}\") res = finder.with_binary_search(tc.strs) self.assertEqual(tc.expected, res, f\"[{tc.name}] - expected {tc.expected}, but got {res}\") if __name__ == \"__main__\": unittest.main() ","date":"2025-01-28","objectID":"/longest_common_prefix/:0:0","tags":null,"title":"Leetcode 11: Longest common prefix","uri":"/longest_common_prefix/"},{"categories":["Leetcode"],"content":"Problem statement: given an array of integers nums and an integer target, return the indices i and j such that nums[i] + nums[j] == target and i != j. You may assume that every input has exactly one pair of indices i and j that satisfy the condition. Return the answer with the smaller index first. Let’s do some thinking. The obvious answer would be to have two nested loops and iterate over nums while checking when the sum equals target, but that’s too easy so surely there must be a better way. We can treat our condition as we would any other equation and do: $$ \\text{nums}[i] + \\text{nums}[j] = \\text{target} \\Leftrightarrow \\text{nums}[j] = \\text{target} - \\text{nums}[i] $$ This means that, if we iterate over nums while calculating the above difference and saving it in a hashmap, if we ever find ourselves in the situation where the difference is already stored as a key in the hashmap, it means that we have found the value that satisfies the above equation together with the value used as a key in the hashmap. Thus, just associate these keys with the index they were calculated from and return the values in the appropriate format when a matching key is found. import unittest from typing import List from dataclasses import dataclass class Sigma(): def two_sum_equals_target(self, nums: List[int], target: int): diffs = {} for i in range(len(nums)): diff = target - nums[i] if diff in diffs: return [diffs[diff], i] diffs[nums[i]] = i class TestSigma(unittest.TestCase): def test_two_sum_equals_target(self): @dataclass class TestCase: name: str nums: list target: int expected: list test_cases = [ TestCase(name=\"working example 1\", nums=[3,4,5,6], target=7, expected=[0, 1]), TestCase(name=\"working example 2\", nums=[4,5,6], target=10, expected=[0, 2]) ] sigma = Sigma() for tc in test_cases: res = sigma.two_sum_equals_target(tc.nums, tc.target) self.assertEqual(tc.expected, res, f\"[{tc.name}] - expected {tc.expected}, but got {res}\") if __name__ == \"__main__\": unittest.main() ","date":"2025-01-28","objectID":"/two_sum/:0:0","tags":null,"title":"Leetcode 10: Two sum","uri":"/two_sum/"},{"categories":["Leetcode"],"content":"Problem statement: given two strings s and t, return true if the two strings are anagrams of each other, otherwise return false. An anagram is a string that contains the exact same characters as another string, but the order of the characters can be different. Not much to say here, this is immediate using Counters, just create one for each string and compare them directly with ==. import unittest from collections import Counter from dataclasses import dataclass class AnagramChecker(): def check(self, s: str, t: str) -\u003e bool: return Counter(s) == Counter(t) class TestAnagramChecker(unittest.TestCase): def test_check(self): @dataclass class TestCase: name: str s: str t: str expected: bool test_cases = [ TestCase(name=\"not an anagram\", s=\"racecar\", t=\"carrace\", expected=True), TestCase(name=\"is an anagram\", s=\"mouse\", t=\"house\", expected=False), TestCase(name=\"works for empty string\", s=\"\", t=\"\", expected=True) ] checker = AnagramChecker() for tc in test_cases: res = checker.check(tc.s, tc.t) self.assertEqual(tc.expected, res, f\"[{tc.name}] - expected {tc.expected} but got {res}\") if __name__ == \"__main__\": unittest.main() ","date":"2025-01-27","objectID":"/valid_anagram/:0:0","tags":null,"title":"Leetcode 9: Valid anagram","uri":"/valid_anagram/"},{"categories":["Leetcode"],"content":"Problem statement: given an integer array nums, return true if any value appears more than once in the array, otherwise return false. We have several ways we can solve this. We can use a standard Python dictionary, where we iteratively store the integers of the array as keys associated with any value and, in case we find a key that already exists, we can adequately flag the array as containing duplicates. We can also use a Counter, give it he full array and compare the total count with the number of keys in the Counter: if these differ, then there are duplicates. Similarly, we can create a set from the array and, in case the set has less values than the array, it contains duplicates. Finally, we can sort the array and iterate over it, checking the current number against the one that follows it and, in case these match, then there is a duplicate. This last option is the least efficient of the bunch since it requires sorting the array. import unittest from collections import Counter from dataclasses import dataclass class DuplicateChecker(): def check_with_dict(self, nums): d = dict() for num in nums: if num in d: return True d[num] = True return False def check_with_counter(self, nums): c = Counter(nums) return True if c.total() != len(c) else False def check_with_set(self, nums): return True if len(set(nums)) != len(nums) else False def check_with_sort(self, nums): nums = sorted(nums) for i in range(len(nums)-1): if nums[i] == nums[i+1]: return True return False class TestDuplicateChecker(unittest.TestCase): def test_check(self): @dataclass class TestCase: name: str input: list expected: bool test_cases = [ TestCase(name=\"empty list has no dups\", input=[], expected=False), TestCase(name=\"single item list has no dups\", input=[1], expected=False), TestCase(name=\"list has no dups\", input=[5, 3, 8, 9], expected=False), TestCase(name=\"list has dups\", input=[5, 3, 8, 9, 0, 9], expected=True) ] checker = DuplicateChecker() for tc in test_cases: res = checker.check_with_counter(tc.input) self.assertEqual(res, tc.expected, f\"[{tc.name}] - with_counter, expected {tc.expected}, but got {res}\") res = checker.check_with_dict(tc.input) self.assertEqual(res, tc.expected, f\"[{tc.name}] - with_dict, expected {tc.expected}, but got {res}\") res = checker.check_with_set(tc.input) self.assertEqual(res, tc.expected, f\"[{tc.name}] - with_set, expected {tc.expected}, but got {res}\") res = checker.check_with_sort(tc.input) self.assertEqual(res, tc.expected, f\"[{tc.name}] - with_sort, expected {tc.expected}, but got {res}\") if __name__ == \"__main__\": unittest.main() ","date":"2025-01-27","objectID":"/contains_duplicate/:0:0","tags":null,"title":"Leetcode 8: Contains duplicate","uri":"/contains_duplicate/"},{"categories":["Leetcode"],"content":"Problem statement: given an integer array nums of length n, you want to create an array ans of length 2n where ans[i] == nums[i] and ans[i+n] == nums[i] for 0 \u003c= i \u003c n (0-indexed). Specifically, ans is the concatenation of two nums array. Return the array ans. I am sure that this exercise is challenging in some programming languages. However, python is not one of them, since we can simply use + to concatenate two arrays. import unittest from dataclasses import dataclass class Concatenator(): def run(self, nums): return nums + nums class TestCase(unittest.TestCase): def test_run(self): @dataclass class TestCase: name: str nums: list expected: list test_cases = [ TestCase(name=\"works as expected\", nums=[1, 2, 3], expected=[1, 2, 3, 1, 2, 3]) ] concatenator = Concatenator() for tc in test_cases: res = concatenator.run(tc.nums) self.assertEqual(tc.expected, res, f\"[{tc.name}] - expected {tc.expected}, but got {res}\") if __name__ == \"__main__\": unittest.main() ","date":"2025-01-27","objectID":"/concatenation_of_array/:0:0","tags":null,"title":"Leetcode 7: Concatenation of array","uri":"/concatenation_of_array/"},{"categories":["Leetcode"],"content":"Problem statement: Assume you have a method which checks if one word is a substring of another. Given two strings, write code to check if the latter is a rotation of the former using only one call to the aforementioned method. This one is super straightforward once you know the trick. If you take the original string and concatenate it with itself, then all of the string’s rotations will be included in the concatenation. Thus, it will then suffice to simply use the method to check if the word is a substring of another and, if it is, then it must be a rotation. Note that we must check the length because rotation preserves the length. import unittest from dataclasses import dataclass class RotationChecker(): def check(self, s: str, t: str) -\u003e bool: if len(s) == len(t) != 0: return t in s+s return False class TestRotationChecker(unittest.TestCase): def test_check(self): @dataclass class TestCase: name: str given1: str given2: str expected: bool test_cases = [ TestCase(name=\"correctly identifies rotation\", given1=\"waterbottle\", given2=\"erbottlewat\", expected=True), TestCase(name=\"correctly identifies not being a rotation\", given1=\"waterbottle\", given2=\"rebottlewat\", expected=False), ] checker = RotationChecker() for tc in test_cases: res = checker.check(tc.given1, tc.given2) self.assertEqual(res, tc.expected, f\"[{tc.name}] - expected {tc.expected}, but got {res}\") if __name__ == \"__main__\": unittest.main() ","date":"2025-01-27","objectID":"/string_rotation/:0:0","tags":null,"title":"Leetcode 6: String rotation","uri":"/string_rotation/"},{"categories":["Leetcode"],"content":"Problem statement: Implement a method to perform basic string compression using the counts of repeated characters. For example, the string aabcccccaaa would become a2b1c5a3. If the compressed string would not become smaller than the original string, your method should return the original string. You can assume the string has only uppercase and lowercase letters. To solve this we need to iterate over each character in the string and, for each character we are currently looking at, we need to check if the previous character is the same while keeping count of how many equal characters we have already seen. Then we just need to verify if our compression is smaller than the given input and we are done. import unittest from dataclasses import dataclass class Compressor(): def run(self, text: str) -\u003e str: compressed = list() count = 0 for i in range(len(text)): if i != 0 and text[i] != text[i-1]: compressed.append(f\"{text[i-1]}{count}\") count = 0 count += 1 if text != \"\": compressed.append(f\"{text[-1]}{count}\") return min(''.join(compressed), text, key=len) class TestCompressor(unittest.TestCase): def test_run(self): @dataclass class TestCase: name: str input: str expected: str test_cases = [ TestCase(name=\"compresses large string\", input=\"aaabbcaaaa\", expected=\"a3b2c1a4\"), TestCase(name=\"returns original if original is smaller\", input=\"abcdefg\", expected=\"abcdefg\"), TestCase(name=\"works for empty string\", input=\"\", expected=\"\") ] compressor = Compressor() for tc in test_cases: res = compressor.run(tc.input) self.assertEqual(tc.expected, res, f\"[{tc.name}] - expected {tc.expected}, but got {res}\") if __name__ == \"__main__\": unittest.main() ","date":"2025-01-27","objectID":"/string_compression/:0:0","tags":null,"title":"Leetcode 5: String compression","uri":"/string_compression/"},{"categories":["Leetcode"],"content":"Problem statement: there are three types of edits that can be performed on strings: insert a character, remove a character, or replace a character. Given two strings, write a function to check if they are one edit (or zero edits) away. This one is very easy to solve. We simply get the frequency counts of the characters in both strings and subtract them, and then count how many keys we get whose value is not zero, since that corresponds to the number of edits. import unittest from collections import Counter from dataclasses import dataclass class EditChecker(): def is_one_edit_away(self, s, t): c = Counter(s) c.subtract(t) num_edits = sum(1 for val in c.values() if val != 0) return True if num_edits \u003c= 1 else False class TestEditChecker(unittest.TestCase): def test_one_edit_away(self): @dataclass class TestCase: name: str str1: str str2: str expected: bool test_cases = [ TestCase(name=\"one operation away\", str1=\"asdf\", str2=\"asdfg\", expected=True), TestCase(name=\"zero operations away\", str1=\"asdf\", str2=\"asdf\", expected=True), TestCase(name=\"works for empty strings\", str1=\"\", str2=\"\", expected=True), TestCase(name=\"works for random characters\", str1=\"123 -kj\", str2=\"12 -kj\", expected=True), TestCase(name=\"one edit and one add away\", str1=\"asdf\", str2=\"sdt\", expected=False), TestCase(name=\"two adds away\", str1=\"asdf\", str2=\"asdfgh\", expected=False), ] checker = EditChecker() for tc in test_cases: res = checker.is_one_edit_away(tc.str1, tc.str2) self.assertEqual(res, tc.expected, msg=f\"[{tc.name}] - expected {tc.expected}, but got {res}\") if __name__ == \"__main__\": unittest.main() ","date":"2025-01-27","objectID":"/one_edit_away/:0:0","tags":null,"title":"Leetcode 4: One edit away","uri":"/one_edit_away/"},{"categories":["Leetcode"],"content":"Problem statement: given a string, write a function to check if it is a permutation of a palindrome. A palindrome is a word or a phrase that is the same forwards and backwards. A permutation is a rearrangement of letters. The palindrome does not need to be limited to just dictionary words. You can ignore casing and non-letter characters. This is a nice exercise because it feels complex but is extremelly straight forward once we think about what we are being asked to do. Basically, we just want to if, if we move the letters around freely, we can get a palindrome. Rather than generate all possible permutations, we can simply notice that a palindrome, like all other words, either has an even or an odd number of characters. Moreover, if it has an even number of characters, then all characters must happen an even number of times. If it has an odd number of characters, then we can only have at most one character with odd number of occurrences. So essentially this problem boils down to a frequency count once again. Then count how many of the counts are odd and, if this number is greater than 1, then there is no palindrome permutation. Otherwise, there is at least one palindrome permutation. import unittest from collections import Counter from dataclasses import dataclass class PalindromeChecker(): def check(self, text: str) -\u003e bool: counts = Counter(text.lower()) number_odd_occurrences = sum(count%2 for count in counts.values()) return True if number_odd_occurrences \u003c= 1 else False class TestPalindromeChecker(unittest.TestCase): def test_check(self): @dataclass class Testcase: name: str input: str expected: bool test_cases = [ Testcase(name=\"all characters are different\", input=\"asdfg\", expected=False), Testcase(name=\"empty string\", input=\"\", expected=True), Testcase(name=\"ignores casing\", input=\"A1kj1Ka\", expected=True), ] checker = PalindromeChecker() for tc in test_cases: res = checker.check(tc.input) self.assertEqual(tc.expected, res, f\"[{tc.name}] - expected {tc.expected}, but got {res}\") if __name__ == \"__main__\": unittest.main() ","date":"2025-01-26","objectID":"/palindrome_permutation/:0:0","tags":null,"title":"Leetcode 3: Palindrome permutation","uri":"/palindrome_permutation/"},{"categories":["Leetcode"],"content":"The first problem I did was pretty simple so lets see if the second one is a bit more interesting. Problem statement: given two strings, write a method to decide if one is a permutation of the other. The first thing to understand is what would classify the strings as being a permutation of one another. Sure we could generate all permutations and check them all, but that would be horribly inefficient and not particularly easier to code. For a string to be a permutation of another they both must have the same characters and they must show up in equal number. This means that all we have to do is get the frequency counts of each string and check if these match. For that purpose we can use a dictionary. However, since this is such a common thing, Python already provides a class designed for such situations, the Counter. We use it to get the frequency counts of the first string, then we use its method subtract to subtract the frequency counts of the second string. Now, if there are any new keys after subtracting, then the strings had different characters and are not palindromes. If the total sum on frequency counts isn’t zero, then it means the strings have the same characters but they show up in different numbers. Putting this together into code and throwing some unit tests in there, we get the following script. import unittest from collections import Counter from dataclasses import dataclass class PermutationChecker(): def check(self, string_1: str, string_2: str) -\u003e bool: character_counts = Counter(string_1) pre_num_chars = len(character_counts) character_counts.subtract(string_2) post_num_chars = len(character_counts) has_same_characters = pre_num_chars == post_num_chars has_same_character_count = character_counts.total() == 0 return True if (has_same_characters and has_same_character_count) else False class TestPermutationChecker(unittest.TestCase): def test_check(self): @dataclass class TestCase: name: str str1: str str2: str expected: bool test_cases = [TestCase(name=\"permutation with just letters\", str1=\"abcd\", str2=\"bacd\", expected=True), TestCase(name=\"permutation with just numbers\", str1=\"3563476\", str2=\"7334566\", expected=True), TestCase(name=\"permutation with alphanumeric\", str1=\"wef34f\", str2=\"wffe34\", expected=True), TestCase(name=\"not a permutation because of different length\", str1=\"abcd\", str2=\"d2cba\", expected=False), TestCase(name=\"not a permutation because of different characters\", str1=\"2354\", str2=\"1234\", expected=False)] checker = PermutationChecker() for tc in test_cases: res = checker.check(tc.str1, tc.str2) self.assertEqual(tc.expected, res, f\"[{tc.name}] - expected {tc.expected} but got {res}\") if __name__ == '__main__': unittest.main() ","date":"2025-01-26","objectID":"/check_permutation/:0:0","tags":null,"title":"Leetcode 2: Check permutation","uri":"/check_permutation/"},{"categories":null,"content":"Hi, I’m Luís! ","date":"2025-01-25","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Work I currently work as a Software Engineer for Stripe. Previously I worked as a Systems Engineer for Cloudflare and before that I worked for freiheit.com technologies as a Software Engineer. ","date":"2025-01-25","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Academic studies I have a BSc in Engineering Physics and a MSc in Applied Mathematics, both granted by University of Lisbon - Instituto Superior Técnico. ","date":"2025-01-25","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":["Leetcode"],"content":"The company I work for decided to do layoffs and fortunately I was not impacted. However, it did get me thinking on whether or not I felt ready to interview with other companies in case I had been fired. And I honestly don’t feel that ready. As such, I bought the Cracking the Coding Interview book and I’m going to be solving every single question that is in the book. Worst case scenario, I’ll learn some new stuff, which isn’t that bad. Plus, I’ll get to refresh my Python knowledge, which is always nice. Okay, first exercise here we go! Problem statement: implement an algorithm to determine if a string has all unique characters. Side note: this is called a heterogram. This is fairly straightforward to solve, all I need to do is iterate over the characters in the string while keeping a ledger of the characters I’ve already seen. I’ll also sprinkle in some nicely formatted unit tests just for good measure. To ensure that this ledger is efficient for lookups (since we’ll have to check every character against it), we use a hashmap to have constant time access. import unittest from dataclasses import dataclass class HeterogramChecker(): def check(self, text): seen = {} for c in text: if c in seen: return False else: seen[c] = True return True class TestHeterogramChecker(unittest.TestCase): def test_check(self): @dataclass class TestCase: name: str input: str expected: bool test_cases = [ TestCase(name=\"heterogram with just letters\", input=\"abcd\", expected=True), TestCase(name=\"heterogram with letters and number\", input=\"s4fad\", expected=True), TestCase(name=\"empty string\", input=\"\", expected=True), TestCase(name=\"repeated number in string\", input=\"23ds2\", expected=False), TestCase(name=\"several repeated characters in string\", input=\"hb 627jh=j ()\", expected=False)] checker = HeterogramChecker() for tc in test_cases: res = checker.check(text=tc.input) self.assertEqual( res, tc.expected, msg=f\"[{tc.name}] expected {tc.expected}, but got {res}\") if __name__ == \"__main__\": unittest.main() ","date":"2025-01-25","objectID":"/is_unique/:0:0","tags":null,"title":"Leetcode 1: Is unique?","uri":"/is_unique/"}]