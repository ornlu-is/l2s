<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>All Posts - lmbf</title>
        <link>https://ornlu-is.github.io/posts/</link>
        <description>All Posts | lmbf</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 25 Aug 2025 21:05:03 &#43;0100</lastBuildDate><atom:link href="https://ornlu-is.github.io/posts/" rel="self" type="application/rss+xml" /><item>
    <title>Leetcode - Two pointers</title>
    <link>https://ornlu-is.github.io/leetcode_two_pointers/</link>
    <pubDate>Mon, 25 Aug 2025 21:05:03 &#43;0100</pubDate>
    <author>Lmbf</author>
    <guid>https://ornlu-is.github.io/leetcode_two_pointers/</guid>
    <description><![CDATA[<p>Two pointer is a fairly common and useful technique for solving leetcode challenges. When several comparisons of pairs in an array are required, this technique tends to be a solid first approach. It boils down to keeping, as the name suggests, two pointers, either one for the first and another for the second element of the array or one for the first and another for the last element of the array.</p>]]></description>
</item>
<item>
    <title>SQL - Compare consecutive entries</title>
    <link>https://ornlu-is.github.io/sql_compare_consecutive_entries/</link>
    <pubDate>Mon, 25 Aug 2025 20:54:29 &#43;0100</pubDate>
    <author>Lmbf</author>
    <guid>https://ornlu-is.github.io/sql_compare_consecutive_entries/</guid>
    <description><![CDATA[<p><strong>Problem</strong>: given a table <code>my_table</code> with an <code>id</code> column, a date column called <code>my_date</code> and a numerically valued column <code>my_value</code>, return the IDs of the rows whose <code>my_value</code> value is larger than their predecessor. Assume that the table is sorted in descending order by <code>my_date</code> and that each entry corresponds to exactly one day.</p>
<p><strong>Solution</strong>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="n">mt1</span><span class="p">.</span><span class="n">id</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">my_table</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">mt1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">JOIN</span><span class="w"> </span><span class="n">my_table</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">mt2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ON</span><span class="w"> </span><span class="n">mt1</span><span class="p">.</span><span class="n">my_date</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mt2</span><span class="p">.</span><span class="n">my_date</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">INTERVAL</span><span class="w"> </span><span class="s1">&#39;1 day&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">mt1</span><span class="p">.</span><span class="n">my_value</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">mt2</span><span class="p">.</span><span class="n">my_value</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>Explanation</strong>: We simply join the table on itself by the <code>my_date</code> column while shifting all dates by one day and then use the <code>WHERE</code> clause to filter for the rows we want to keep. This trick is highly localized in the sense that it requires all days to exist, otherwise it would fail.</p>]]></description>
</item>
<item>
    <title>SQL - Find duplicates</title>
    <link>https://ornlu-is.github.io/sql_find_duplicates/</link>
    <pubDate>Tue, 19 Aug 2025 21:13:22 &#43;0100</pubDate>
    <author>Lmbf</author>
    <guid>https://ornlu-is.github.io/sql_find_duplicates/</guid>
    <description><![CDATA[<p><strong>Problem</strong>: given a table <code>my_table</code> with two columns: <code>id</code> representing a unique identifier and constituting the table&rsquo;s primary key and <code>col1</code> being a text column, we want to write a query that finds all values of <code>col1</code> of <code>my_table</code> that have one or more duplicates.</p>
<p><strong>Solution</strong>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="n">col1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">my_table</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">col1</span><span class="w"> </span><span class="k">HAVING</span><span class="w"> </span><span class="k">COUNT</span><span class="p">(</span><span class="n">col1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>Explanation</strong>: this is pretty straightforward, we simply group by <code>col1</code> which will cause us to produce a table composed uniquely of the distinct values of <code>col1</code>. By specifying <code>HAVING COUNT(col1) &gt; 1</code>, we are essentially filtering the table of distinct values of <code>col1</code> to restrict ourselves to the values that occur more than once.</p>]]></description>
</item>
<item>
    <title>SQL - Second highest distinct value</title>
    <link>https://ornlu-is.github.io/sql_second_highest_distinct_value/</link>
    <pubDate>Tue, 19 Aug 2025 20:59:40 &#43;0100</pubDate>
    <author>Lmbf</author>
    <guid>https://ornlu-is.github.io/sql_second_highest_distinct_value/</guid>
    <description><![CDATA[<p><strong>Problem</strong>: given a table <code>my_table</code> with an numeric column <code>col</code>, we want to return the second highest distinct value. In case there is no second highest (for example, when the table only has one row or all the rows in the table have the same value), we want to return <code>null</code>.</p>
<p><strong>Solution</strong>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="k">MAX</span><span class="p">(</span><span class="n">col</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">my_table</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">IN</span><span class="w"> </span><span class="p">(</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">SELECT</span><span class="w"> </span><span class="k">MAX</span><span class="p">(</span><span class="n">col</span><span class="p">)</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">FROM</span><span class="w"> </span><span class="n">my_table</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>Explanation</strong>: This is a nifty trick. The subquery simply produces a temporary table with one single value, the maximum of the column <code>col</code> of table <code>my_table</code>. Then we again select the maximum value of column <code>col</code> of <code>my_table</code> where the value is <strong>not</strong> in the temporary table we&rsquo;ve produced, <em>i.e.</em>, the maximum of the values that include every value except the actual maximum is the second highest value. Additionally, if there is no second highest value, there is nothing to select so we naturally produce a <code>null</code> value.</p>]]></description>
</item>
<item>
    <title>High-level view of storing data in a database</title>
    <link>https://ornlu-is.github.io/records_and_pages_in_disk/</link>
    <pubDate>Thu, 14 Aug 2025 20:17:37 &#43;0000</pubDate>
    <author>Lmbf</author>
    <guid>https://ornlu-is.github.io/records_and_pages_in_disk/</guid>
    <description><![CDATA[<figure><figcaption>
      <h4>Records, bytes, tables, pages and files</h4>
    </figcaption>
</figure>

<ul>
<li><strong>Record</strong> - a set of information grouped together, where the different pieces of information can have different types;</li>
<li><strong>Byte representation of a record</strong> - how the record is actually stored in disk as bytes. Since records can have fields of different types, not all fields take up the same amount of bytes. Additionally, fields can be of fixed size, such as <code>char</code>, or of variable size, such as <code>varchar</code>. The specification of the types that compose a record is called a schema;
<ul>
<li>There are many ways a record can be represented in disk. For example, records can be of <strong>fixed</strong> length or of <strong>variable</strong> length and this obviously changes how we store and access them. However, the goals are always the same: records should be compact in memory/disk and there should be fast access to their fields;</li>
</ul>
</li>
<li><strong>Table</strong> - a collection of records sharing a schema;</li>
<li><strong>Page</strong> - a chunk of sequential bytes that composes a unit of transfer for disk read/write and that can hold multiple records;
<ul>
<li>Much like records, the way page layout is handled is also affected by whether or not the records are of fixed length. Most notably, the records in a page can be <strong>packed</strong> or <strong>unpacked</strong>, where packed refers to not having &ldquo;empty&rdquo; bytes between records in a page;</li>
</ul>
</li>
<li><strong>File</strong> - a logical collection of pages that compose a table. Note that tables can span multiple files or even multiple machines;
<ul>
<li>Files themselves in a database can be structured in a variety of ways: unordered heap files (records placed arbitrarily across pages), clustered heap files (records and pages are grouped), sorted files (pages and records are in sorter order), index files (B+ trees, linear hashing, etc., may contain records or point to records in other files), etc.</li>
</ul>
</li>
</ul>
<p><em>Note that we&rsquo;ve used a slotted page as an example, but that is just one out of many possible ways to manage records in a page.</em></p>]]></description>
</item>
</channel>
</rss>
